formparam<-as.HMSCparam(formdata,formprior,paramLatentAuto=comm$param$paramLatentAuto,
latentAuto=comm$param$latentAuto,paramAuto=comm$param$paramAuto,
shrinkLocalAutocomm$param$shrinkLocalAuto,
paramShrinkGlobalAuto=comm$param$paramShrinkGlobalAuto)
CoordAuto<-matrix(NA,nrow=nlevels(formdata$Auto[[1]][,1]),ncol=2)
colnames(CoordAuto)<-paste("coord",1:2,sep="")
rownames(CoordAuto)<-levels(formdata$Auto[[1]][,1])
for(i in 1:2){
CoordAuto[,i]<-tapply(formdata$Auto[[1]][,i+1],formdata$Auto[[1]][,1],mean)
}
CoordAuto
rm(list=ls())
library(HMSC)
set.seed(125)
#================
### Generate data
#================
nsite <- 10
autocor1<-data.frame(as.factor(rep(1:(nsite/4),each=4)),runif(1:nsite),runif(1:nsite))
nsp<-2
comm<-communitySimul(nsp=nsp,Auto=autocor1)
#=============
### Formatting
#=============
### Format data
formdata<-as.HMSCdata(Y=comm$data$Y,Auto=comm$data$Auto)
formprior<-as.HMSCprior(formdata,family="probit")
formparam<-as.HMSCparam(formdata,formprior,paramLatentAuto=comm$param$paramLatentAuto,
latentAuto=comm$param$latentAuto,paramAuto=comm$param$paramAuto,
shrinkLocalAutocomm$param$shrinkLocalAuto,
paramShrinkGlobalAuto=comm$param$paramShrinkGlobalAuto)
CoordAuto<-matrix(NA,nrow=nlevels(formdata$Auto[[1]][,1]),ncol=2)
colnames(CoordAuto)<-paste("coord",1:2,sep="")
rownames(CoordAuto)<-levels(formdata$Auto[[1]][,1])
for(i in 1:2){
CoordAuto[,i]<-tapply(formdata$Auto[[1]][,i+1],formdata$Auto[[1]][,1],mean)
}
nsite <- 20
autocor1<-data.frame(as.factor(rep(1:(nsite/4),each=4)),runif(1:nsite),runif(1:nsite))
nsp<-2
comm<-communitySimul(nsp=nsp,Auto=autocor1)
#=============
### Formatting
#=============
### Format data
formdata<-as.HMSCdata(Y=comm$data$Y,Auto=comm$data$Auto)
formprior<-as.HMSCprior(formdata,family="probit")
formparam<-as.HMSCparam(formdata,formprior,paramLatentAuto=comm$param$paramLatentAuto,
latentAuto=comm$param$latentAuto,paramAuto=comm$param$paramAuto,
shrinkLocalAutocomm$param$shrinkLocalAuto,
paramShrinkGlobalAuto=comm$param$paramShrinkGlobalAuto)
CoordAuto<-matrix(NA,nrow=nlevels(formdata$Auto[[1]][,1]),ncol=2)
colnames(CoordAuto)<-paste("coord",1:2,sep="")
rownames(CoordAuto)<-levels(formdata$Auto[[1]][,1])
for(i in 1:2){
CoordAuto[,i]<-tapply(formdata$Auto[[1]][,i+1],formdata$Auto[[1]][,1],mean)
}
#==============
formprior
formparam
rm(list=ls())
library(HMSC)
set.seed(125)
#================
### Generate data
#================
nsite <- 1000
autocor1<-data.frame(as.factor(rep(1:(nsite/4),each=4)),runif(1:nsite),runif(1:nsite))
nsp<-10
comm<-communitySimul(nsp=nsp,Auto=autocor1)
#=============
### Formatting
#=============
### Format data
formdata<-as.HMSCdata(Y=comm$data$Y,Auto=comm$data$Auto)
formprior<-as.HMSCprior(formdata,family="probit")
formparam<-as.HMSCparam(formdata,formprior,paramLatentAuto=comm$param$paramLatentAuto,
latentAuto=comm$param$latentAuto,paramAuto=comm$param$paramAuto,
shrinkLocalAutocomm$param$shrinkLocalAuto,
paramShrinkGlobalAuto=comm$param$paramShrinkGlobalAuto)
CoordAuto<-matrix(NA,nrow=nlevels(formdata$Auto[[1]][,1]),ncol=2)
colnames(CoordAuto)<-paste("coord",1:2,sep="")
rownames(CoordAuto)<-levels(formdata$Auto[[1]][,1])
for(i in 1:2){
CoordAuto[,i]<-tapply(formdata$Auto[[1]][,i+1],formdata$Auto[[1]][,1],mean)
}
#==============
### Build model
#==============
model<-hmsc(formdata,formparam,formprior,family="probit",niter=1000,nburn=100,thin=1)
#===========================================
### Test paramAuto through covariance matrix
#===========================================
covMat<-corRandomEff(model,cor=FALSE)
### First random effect
ltri<-lower.tri(apply(covMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
covMat.025<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.025)[ltri])
covMat.975<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.975)[ltri])
IC<-cbind(covMat.025,covMat.975)
vrai<-as.vector(tcrossprod(comm$param$paramLatentAuto[[1]])[ltri])
testres <- apply(cbind(IC[,1]<vrai,IC[,2]>vrai),1,all)
testres
IC
plot(1:55,type="n",ylim=range(IC,vrai))
plot(vrai,type="n",ylim=range(IC,vrai))
plot(vrai,ylim=range(IC,vrai))
arrows(x0=1:55,x1=1:55,y0=IC[,1],y1=IC[,2],code=3,angle=90,length=0.02)
covMat<-corRandomEff(model,cor=TRUE)
### First random effect
ltri<-lower.tri(apply(covMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
covMat.025<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.025)[ltri])
covMat.975<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.975)[ltri])
IC<-cbind(covMat.025,covMat.975)
vrai<-as.vector(cor2cov(tcrossprod(comm$param$paramLatentAuto[[1]]))[ltri])
covMat<-corRandomEff(model,cor=TRUE)
### First random effect
ltri<-lower.tri(apply(covMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
covMat.025<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.025)[ltri])
covMat.975<-as.vector(apply(covMat[,,,1],1:2,quantile,probs=0.975)[ltri])
IC<-cbind(covMat.025,covMat.975)
vrai<-as.vector(cov2cor(tcrossprod(comm$param$paramLatentAuto[[1]]))[ltri])
plot(vrai,ylim=range(IC,vrai))
arrows(x0=1:55,x1=1:55,y0=IC[,1],y1=IC[,2],code=3,angle=90,length=0.02)
tcrossprod(comm$param$paramLatentAuto[[1]])
cov2cor(tcrossprod(comm$param$paramLatentAuto[[1]]))
IC
exp(1+2)
exp(1)*exp(2)
library(rootSolve)
?stode
diffusion3D <- function(t, Y, par)   {
yy    <- array(dim=c(n,n,n),data=Y)  # vector to 3-D array
dY   <- -r*yy        # consumption
BND   <- rep(1,n)   # boundary concentration
for (i in 1:n) {
y <- yy[i,,]
#diffusion in X-direction; boundaries=imposed concentration
Flux <- -Dy * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dy
dY[i,,]   <- dY[i,,] - (Flux[2:(n+1),]-Flux[1:n,])/dy
#diffusion in Y-direction
Flux <- -Dz * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dz
dY[i,,]    <- dY[i,,] - (Flux[,2:(n+1)]-Flux[,1:n])/dz
}
for (j in 1:n) {
y <- yy[,j,]
#diffusion in X-direction; boundaries=imposed concentration
Flux <- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
dY[,j,]   <- dY[,j,] - (Flux[2:(n+1),]-Flux[1:n,])/dx
#diffusion in Y-direction
Flux <- -Dz * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dz
dY[,j,]    <- dY[,j,] - (Flux[,2:(n+1)]-Flux[,1:n])/dz
}
for (k in 1:n) {
y <- yy[,,k]
#diffusion in X-direction; boundaries=imposed concentration
Flux <- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
dY[,,k]   <- dY[,,k] - (Flux[2:(n+1),]-Flux[1:n,])/dx
#diffusion in Y-direction
Flux <- -Dy * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dy
dY[,,k]    <- dY[,,k] - (Flux[,2:(n+1)]-Flux[,1:n])/dy
}
return(list(as.vector(dY)))
}
# parameters
dy    <- dx <- dz <-1   # grid size
Dy    <- Dx <- Dz <-1   # diffusion coeff, X- and Y-direction
r     <- 0.025     # consumption rate
n  <- 10
y  <- array(dim=c(n, n, n), data = 10.)
# stodes is used, so we should specify the size of the work array (lrw)
# We take a rather large value initially
print(system.time(
ST3 <- steady.3D(y, func =diffusion3D, parms = NULL, pos = TRUE,
dimens = c(n, n, n), lrw = 100000,
atol = 1e-10, rtol = 1e-10, ctol = 1e-10,
verbose = TRUE)
))
attributes(ST3)
# image plot
y <- array(dim=c(n, n, n), data = ST3$y)
filled.contour(y[ , ,n/2], color.palette = terrain.colors)
# rootSolve's image plot, looping over 3rd dimension
image(ST3, mfrow = c(4,3))
# loop over 1st dimension, contours, legends added
image(ST3, mfrow = c(2, 2), add.contour = TRUE, legend = TRUE,
dimselect = list(x = c(1, 4, 8, 10)))
diffusion2D <- function(t, Y, par)   {
y    <- matrix(nr=n,nc=n,data=Y)  # vector to 2-D matrix
dY   <- -r*y        # consumption
BND   <- rep(1,n)   # boundary concentration
#diffusion in X-direction; boundaries=imposed concentration
Flux <- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
dY   <- dY - (Flux[2:(n+1),]-Flux[1:n,])/dx
#diffusion in Y-direction
Flux <- -Dy * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dy
dY    <- dY - (Flux[,2:(n+1)]-Flux[,1:n])/dy
return(list(as.vector(dY)))
}
# parameters
dy    <- dx <- 1   # grid size
Dy    <- Dx <- 1   # diffusion coeff, X- and Y-direction
r     <- 0.025     # consumption rate
n  <- 100
y  <- matrix(nrow = n, ncol = n, 10.)
# stodes is used, so we should specify the size of the work array (lrw)
# We take a rather large value
system.time(
ST2 <- steady.2D(y, func = diffusion2D, parms = NULL, pos = TRUE,
dimens = c(n, n), lrw = 1000000,
atol = 1e-10, rtol = 1e-10, ctol = 1e-10)
)
## Not run:   # this takes a long time...
system.time(
ST3 <- steady.2D(y, func = diffusion2D, parms = NULL,
dimens = c(n, n), lrw = 1000000, method = "runsteady",
time = c(0, 1e6), atol = 1e-10, rtol = 1e-10)
)
## End(Not run)
# the actual size of lrw is in the attributes()$dims vector.
# it is best to set lrw as small as possible
attributes(ST2)
image(ST2, legend = TRUE)
image(ST1, legend = TRUE)
image(ST3, legend = TRUE)
image(ST2, legend = TRUE)
image(ST2, legend = TRUE)
image(ST2, legend = TRUE)
diffusion2Db <- function(t, Y, par)  {
y    <- matrix(nr=nx,nc=ny,data=Y)  # vector to 2-D matrix
dY   <- -r*y        # consumption
BNDx   <- rep(1,nx)   # boundary concentration
BNDy   <- rep(1,ny)   # boundary concentration
#diffusion in X-direction; boundaries=imposed concentration
Flux <- -Dx * rbind(y[1,]-BNDy,(y[2:nx,]-y[1:(nx-1),]),BNDy-y[nx,])/dx
dY   <- dY - (Flux[2:(nx+1),]-Flux[1:nx,])/dx
#diffusion in Y-direction
Flux <- -Dy * cbind(y[,1]-BNDx,(y[,2:ny]-y[,1:(ny-1)]),BNDx-y[,ny])/dy
dY    <- dY - (Flux[,2:(ny+1)]-Flux[,1:ny])/dy
# extra flux on two sides
dY[,1] <- dY[,1]+  10
dY[1,] <- dY[1,]+  10
# and exchange between sides on y-direction
dY[,ny] <- dY[,ny]+ (y[,1]-y[,ny])*10
return(list(as.vector(dY)))
}
# parameters
dy    <- dx <- 1   # grid size
Dy    <- Dx <- 1   # diffusion coeff, X- and Y-direction
r     <- 0.025     # consumption rate
nx  <- 50
ny  <- 100
y  <- matrix(nrow = nx, ncol = ny, 10.)
print(system.time(
ST2 <- steady.2D(y, func = diffusion2Db, parms = NULL, pos = TRUE,
dimens = c(nx, ny), verbose = TRUE, lrw = 283800,
atol = 1e-10, rtol = 1e-10, ctol = 1e-10,
cyclicBnd = 2)       # y-direction: cyclic boundary
))
image(ST2)
#y <- matrix(nrow = nx, ncol = ny, data = ST2$y)
#    filled.contour(y,color.palette=terrain.colors)
uniroot.all()
uniroot.all
setwd("~/Documents/Recherche/Cours donnÃ©s/2017/Joint modelling/Simulated data/")
ls()
coco<-read.csv("C.csv")
coco
isSymmetric.matrix(coco)
isSymmetric(coco)
isSymmetric.matrix(as.matrix(coco))
rm(list=ls())
library(HMSC)
data("simulEx1")
data("simulParamEx1")
model<-hmsc(simulEx1,family="probit",niter=10000,nburn=1000,thin=10)
truth<-as.vector(simulParamEx1$param$paramX)
average<-apply(model$results$estimation$paramX,1:2,mean)
CI.025<-apply(model$results$estimation$paramX,1:2,quantile, probs=0.025)
CI.975<-apply(model$results$estimation$paramX,1:2,quantile, probs=0.975)
CI<-cbind(as.vector(CI.025),as.vector(CI.975))
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",ylab="",main="paramX")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramX")
plot(mixing)
plot(mixing)
mixingDF<-as.data.frame(mixing)
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
corMat<-corRandomEff(model,cor=FALSE)
ltri<-lower.tri(apply(corMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx1$param$paramLatent[[1]])[ltri])
average<-as.vector(apply(corMat[,,,1],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",,main="cov(paramLatent[[1,1]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramLatent")
plot(mixing[[1]])
mixingDF<-as.data.frame(mixing[[1]])
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
library(corrplot)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
colMat<-matrix(NA,nrow=nrow(averageCor),ncol=ncol(averageCor))
colMat[which(averageCor>0.4,arr.ind=TRUE)]<-"red"
colMat[which(averageCor< -0.4,arr.ind=TRUE)]<-"blue"
chordDiagram(averageCor,symmetric=TRUE,annotationTrack=c("name","grid"),grid.col="grey",col=colMat)
ltri<-lower.tri(apply(corMat[,,,2],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx1$param$paramLatent[[2]])[ltri])
average<-as.vector(apply(corMat[,,,2],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",main="cov(paramLatent[[1,2]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
ltri<-lower.tri(apply(corMat[,,,2],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx1$param$paramLatent[[2]])[ltri])
average<-as.vector(apply(corMat[,,,2],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",main="cov(paramLatent[[1,2]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
corMat<-corRandomEff(model,cor=FALSE)
ltri<-lower.tri(apply(corMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx1$param$paramLatent[[1]])[ltri])
average<-as.vector(apply(corMat[,,,1],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",,main="cov(paramLatent[[1,1]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramLatent")
plot(mixing[[1]])
mixingDF<-as.data.frame(mixing[[1]])
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
library(corrplot)
averageCor<-apply(corMat[,,,1],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
averageCor<-apply(corMat[,,,1],1:2,mean)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
colMat<-matrix(NA,nrow=nrow(averageCor),ncol=ncol(averageCor))
colMat[which(averageCor>0.4,arr.ind=TRUE)]<-"red"
colMat[which(averageCor< -0.4,arr.ind=TRUE)]<-"blue"
chordDiagram(averageCor,symmetric=TRUE,annotationTrack=c("name","grid"),grid.col="grey",col=colMat)
corMat<-corRandomEff(model,cor=FALSE)
ltri<-lower.tri(apply(corMat[,,,2],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx1$param$paramLatent[[2]])[ltri])
average<-as.vector(apply(corMat[,,,2],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",main="cov(paramLatent[[1,2]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramLatent")
plot(mixing[[2]])
mixingDF<-as.data.frame(mixing[[2]])
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
library(corrplot)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,2],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,2],1:2,mean)
colMat<-matrix(NA,nrow=nrow(averageCor),ncol=ncol(averageCor))
colMat[which(averageCor>0.4,arr.ind=TRUE)]<-"red"
colMat[which(averageCor< -0.4,arr.ind=TRUE)]<-"blue"
chordDiagram(averageCor,symmetric=TRUE,annotationTrack=c("name","grid"),grid.col="grey",col=colMat)
rm(list=ls())
library(HMSC)
data("simulEx2")
data("simulParamEx2")
model<-hmsc(simulEx2,family="probit",niter=10000,nburn=1000,thin=10)
truth<-as.vector(simulParamEx2$param$paramX)
average<-apply(model$results$estimation$paramX,1:2,mean)
CI.025<-apply(model$results$estimation$paramX,1:2,quantile, probs=0.025)
CI.975<-apply(model$results$estimation$paramX,1:2,quantile, probs=0.975)
CI<-cbind(as.vector(CI.025),as.vector(CI.975))
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",ylab="",main="paramX")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramX")
plot(mixing)
mixingDF<-as.data.frame(mixing)
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
truth<-as.vector(simulParamEx2$param$paramTr)
average<-apply(model$results$estimation$paramTr,1:2,mean)
CI.025<-apply(model$results$estimation$paramTr,1:2,quantile, probs=0.025)
CI.975<-apply(model$results$estimation$paramTr,1:2,quantile, probs=0.975)
CI<-cbind(as.vector(CI.025),as.vector(CI.975))
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",ylab="",main="paramX")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramTr")
plot(mixing)
par(mar=c(7,4,4,2))
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
corMat<-corRandomEff(model,cor=FALSE)
ltri<-lower.tri(apply(corMat[,,,1],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx2$param$paramLatent[[1]])[ltri])
average<-as.vector(apply(corMat[,,,1],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,1],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",,main="cov(paramLatent[[1,1]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramLatent")
plot(mixing[[1]])
mixingDF<-as.data.frame(mixing[[1]])
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
library(corrplot)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,1],1:2,mean)
colMat<-matrix(NA,nrow=nrow(averageCor),ncol=ncol(averageCor))
colMat[which(averageCor>0.4,arr.ind=TRUE)]<-"red"
colMat[which(averageCor< -0.4,arr.ind=TRUE)]<-"blue"
chordDiagram(averageCor,symmetric=TRUE,annotationTrack=c("name","grid"),grid.col="grey",col=colMat)
corMat<-corRandomEff(model,cor=FALSE)
ltri<-lower.tri(apply(corMat[,,,2],1:2,quantile,probs=0.025),diag=TRUE)
truth<-as.vector(tcrossprod(simulParamEx2$param$paramLatent[[2]])[ltri])
average<-as.vector(apply(corMat[,,,2],1:2,mean)[ltri])
corMat.025<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.025)[ltri])
corMat.975<-as.vector(apply(corMat[,,,2],1:2,quantile,probs=0.975)[ltri])
CI<-cbind(corMat.025,corMat.975)
plot(0,0,xlim=c(1,nrow(CI)),ylim=range(CI,truth),type="n",xlab="",main="cov(paramLatent[[1,2]])")
abline(h=0,col="grey")
arrows(x0=1:nrow(CI),x1=1:nrow(CI),y0=CI[,1],y1=CI[,2],code=3,angle=90,length=0.05)
points(1:nrow(CI),average,pch=15,cex=1.5)
points(1:nrow(CI),truth,col="red",pch=19)
mixing<-as.mcmc(model,parameters="paramLatent")
plot(mixing[[2]])
par(mar=c(7,4,4,2))
boxplot(mixingDF,las=2)
library(beanplot)
par(mar=c(7,4,4,2))
beanplot(mixingDF,las=2)
library(corrplot)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,2],1:2,mean)
corrplot(averageCor,method="color",col=colorRampPalette(c("blue","white","red"))(200))
library(circlize)
corMat<-corRandomEff(model,cor=TRUE)
averageCor<-apply(corMat[,,,2],1:2,mean)
colMat<-matrix(NA,nrow=nrow(averageCor),ncol=ncol(averageCor))
colMat[which(averageCor>0.4,arr.ind=TRUE)]<-"red"
colMat[which(averageCor< -0.4,arr.ind=TRUE)]<-"blue"
chordDiagram(averageCor,symmetric=TRUE,annotationTrack=c("name","grid"),grid.col="grey",col=colMat)
